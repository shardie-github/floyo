/**
 * Cost & Efficiency Agent
 * Tracks cloud costs and suggests optimizations
 */

import { writeFileSync, existsSync, readFileSync } from 'fs';
import { join } from 'path';
import type { RepoContext } from './repo-context.js';

export interface CostMetrics {
  timestamp: string;
  monthlySpend: {
    vercel?: number;
    supabase?: number;
    expo?: number;
    total: number;
  };
  projectedMonthly: number;
  overrun: boolean;
  overrunPercent?: number;
  recommendations: Array<{
    provider: string;
    suggestion: string;
    estimatedSavings: number;
  }>;
}

export class CostAgent {
  private workspacePath: string;
  private thresholdPercent: number;

  constructor(
    workspacePath: string = process.cwd(),
    thresholdPercent: number = 10
  ) {
    this.workspacePath = workspacePath;
    this.thresholdPercent = thresholdPercent;
  }

  /**
   * Collect cost metrics
   * Note: In production, this would integrate with Vercel/Supabase/Expo APIs
   */
  async collectMetrics(context: RepoContext): Promise<CostMetrics> {
    const metrics: CostMetrics = {
      timestamp: new Date().toISOString(),
      monthlySpend: {
        total: 0,
      },
      projectedMonthly: 0,
      overrun: false,
      recommendations: [],
    };

    // Estimate costs based on context
    if (context.cloudProviders.includes('vercel')) {
      metrics.monthlySpend.vercel = this.estimateVercelCost(context);
      metrics.monthlySpend.total += metrics.monthlySpend.vercel;
    }

    if (context.cloudProviders.includes('supabase')) {
      metrics.monthlySpend.supabase = this.estimateSupabaseCost(context);
      metrics.monthlySpend.total += metrics.monthlySpend.supabase;
    }

    if (context.hasMobile && context.frameworks.includes('expo')) {
      metrics.monthlySpend.expo = this.estimateExpoCost(context);
      metrics.monthlySpend.total += metrics.monthlySpend.expo;
    }

    // Project monthly spend (simple projection)
    metrics.projectedMonthly = metrics.monthlySpend.total * 1.1; // 10% buffer

    // Check for overruns
    const baseline = this.getBaselineCost();
    if (baseline > 0) {
      const changePercent =
        ((metrics.monthlySpend.total - baseline) / baseline) * 100;
      if (changePercent > this.thresholdPercent) {
        metrics.overrun = true;
        metrics.overrunPercent = changePercent;
      }
    }

    // Generate recommendations
    this.generateRecommendations(metrics, context);

    return metrics;
  }

  /**
   * Save cost metrics
   */
  saveMetrics(metrics: CostMetrics): void {
    const costPath = join(this.workspacePath, 'admin', 'cost.json');
    const adminDir = join(this.workspacePath, 'admin');
    if (!existsSync(adminDir)) {
      require('fs').mkdirSync(adminDir, { recursive: true });
    }

    writeFileSync(costPath, JSON.stringify(metrics, null, 2), 'utf-8');
  }

  /**
   * Generate cost report
   */
  generateReport(metrics: CostMetrics): string {
    const report = `# Cost & Efficiency Report

Generated: ${metrics.timestamp}

## Monthly Spend
- Vercel: $${metrics.monthlySpend.vercel?.toFixed(2) || 'N/A'}
- Supabase: $${metrics.monthlySpend.supabase?.toFixed(2) || 'N/A'}
- Expo: $${metrics.monthlySpend.expo?.toFixed(2) || 'N/A'}
- **Total: $${metrics.monthlySpend.total.toFixed(2)}**

## Projected Monthly
- **$${metrics.projectedMonthly.toFixed(2)}**

## Cost Status
${metrics.overrun
  ? `⚠️ **OVERRUN DETECTED**: ${metrics.overrunPercent?.toFixed(2)}% above baseline`
  : '✅ Within budget'}

## Recommendations
${metrics.recommendations.length > 0
  ? metrics.recommendations
      .map(
        (r) =>
          `- **${r.provider}**: ${r.suggestion} (Est. savings: $${r.estimatedSavings.toFixed(2)}/month)`
      )
      .join('\n')
  : 'No immediate cost optimizations needed ✅'}

---
*Auto-generated by Unified Agent System*
`;

    const reportPath = join(this.workspacePath, 'admin', 'cost.md');
    writeFileSync(reportPath, report, 'utf-8');
    return report;
  }

  private estimateVercelCost(context: RepoContext): number {
    // Basic estimation based on typical usage
    // In production, would fetch from Vercel API
    return 20; // $20/month estimate
  }

  private estimateSupabaseCost(context: RepoContext): number {
    // Basic estimation
    return 25; // $25/month estimate
  }

  private estimateExpoCost(context: RepoContext): number {
    // Basic estimation
    return 0; // Expo free tier
  }

  private getBaselineCost(): number {
    const costPath = join(this.workspacePath, 'admin', 'cost.json');
    if (!existsSync(costPath)) {
      return 0;
    }

    try {
      const previous = JSON.parse(readFileSync(costPath, 'utf-8'));
      return previous.monthlySpend?.total || 0;
    } catch {
      return 0;
    }
  }

  private generateRecommendations(
    metrics: CostMetrics,
    context: RepoContext
  ): void {
    // Suggest caching if high Vercel costs
    if (metrics.monthlySpend.vercel && metrics.monthlySpend.vercel > 50) {
      metrics.recommendations.push({
        provider: 'Vercel',
        suggestion: 'Enable edge caching and reduce function execution time',
        estimatedSavings: metrics.monthlySpend.vercel * 0.2,
      });
    }

    // Suggest query optimization if high Supabase costs
    if (metrics.monthlySpend.supabase && metrics.monthlySpend.supabase > 50) {
      metrics.recommendations.push({
        provider: 'Supabase',
        suggestion: 'Optimize database queries and enable connection pooling',
        estimatedSavings: metrics.monthlySpend.supabase * 0.15,
      });
    }
  }
}
