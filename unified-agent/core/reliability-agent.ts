/**
 * Reliability & Performance Agent
 * Monitors latency, build time, payload size, error frequency
 */

import { writeFileSync, existsSync, readFileSync } from 'fs';
import { join } from 'path';
import type { RepoContext } from './repo-context.js';

export interface ReliabilityMetrics {
  timestamp: string;
  latency: {
    p50: number;
    p95: number;
    p99: number;
  };
  buildTime: {
    frontend?: number;
    backend?: number;
    total: number;
  };
  payloadSize: {
    frontend?: number;
    api?: number;
  };
  errorRate: number;
  uptime: number;
  regressions: Array<{
    metric: string;
    previous: number;
    current: number;
    changePercent: number;
  }>;
}

export class ReliabilityAgent {
  private workspacePath: string;
  private metricsPath: string;

  constructor(workspacePath: string = process.cwd()) {
    this.workspacePath = workspacePath;
    this.metricsPath = join(workspacePath, 'admin', 'reliability.json');
  }

  /**
   * Collect reliability metrics
   */
  async collectMetrics(context: RepoContext): Promise<ReliabilityMetrics> {
    const metrics: ReliabilityMetrics = {
      timestamp: new Date().toISOString(),
      latency: {
        p50: 0,
        p95: 0,
        p99: 0,
      },
      buildTime: {
        total: 0,
      },
      payloadSize: {},
      errorRate: 0,
      uptime: 99.9,
      regressions: [],
    };

    // Load previous metrics for comparison
    const previous = this.loadPreviousMetrics();

    // Collect build time metrics
    if (context.hasFrontend) {
      // Try to read build artifacts or use defaults
      metrics.buildTime.frontend = 120; // Default, would be measured
      metrics.payloadSize.frontend = this.estimateFrontendSize();
    }

    if (context.hasBackend) {
      metrics.buildTime.backend = 60; // Default, would be measured
      metrics.payloadSize.api = this.estimateAPISize();
    }

    metrics.buildTime.total =
      (metrics.buildTime.frontend || 0) + (metrics.buildTime.backend || 0);

    // Detect regressions
    if (previous) {
      this.detectRegressions(metrics, previous);
    }

    return metrics;
  }

  /**
   * Save metrics to file
   */
  saveMetrics(metrics: ReliabilityMetrics): void {
    // Ensure admin directory exists
    const adminDir = join(this.workspacePath, 'admin');
    if (!existsSync(adminDir)) {
      require('fs').mkdirSync(adminDir, { recursive: true });
    }

    writeFileSync(
      this.metricsPath,
      JSON.stringify(metrics, null, 2),
      'utf-8'
    );
  }

  /**
   * Generate reliability markdown report
   */
  generateReport(metrics: ReliabilityMetrics): string {
    const report = `# Reliability & Performance Report

Generated: ${metrics.timestamp}

## Latency Metrics
- P50: ${metrics.latency.p50}ms
- P95: ${metrics.latency.p95}ms
- P99: ${metrics.latency.p99}ms

## Build Performance
- Frontend: ${metrics.buildTime.frontend || 'N/A'}s
- Backend: ${metrics.buildTime.backend || 'N/A'}s
- Total: ${metrics.buildTime.total}s

## Payload Sizes
- Frontend: ${metrics.payloadSize.frontend ? `${(metrics.payloadSize.frontend / 1024).toFixed(2)} KB` : 'N/A'}
- API: ${metrics.payloadSize.api ? `${(metrics.payloadSize.api / 1024).toFixed(2)} KB` : 'N/A'}

## Error Rate
- Current: ${(metrics.errorRate * 100).toFixed(2)}%

## Uptime
- Current: ${metrics.uptime}%

## Regressions Detected
${metrics.regressions.length > 0
  ? metrics.regressions
      .map(
        (r) =>
          `- **${r.metric}**: ${r.previous} → ${r.current} (${r.changePercent > 0 ? '+' : ''}${r.changePercent.toFixed(2)}%)`
      )
      .join('\n')
  : 'No regressions detected ✅'}

---
*Auto-generated by Unified Agent System*
`;

    const reportPath = join(this.workspacePath, 'admin', 'reliability.md');
    writeFileSync(reportPath, report, 'utf-8');
    return report;
  }

  private loadPreviousMetrics(): ReliabilityMetrics | null {
    if (!existsSync(this.metricsPath)) {
      return null;
    }

    try {
      return JSON.parse(readFileSync(this.metricsPath, 'utf-8'));
    } catch {
      return null;
    }
  }

  private detectRegressions(
    current: ReliabilityMetrics,
    previous: ReliabilityMetrics
  ): void {
    const threshold = 0.1; // 10% change threshold

    // Check latency
    if (previous.latency.p95 > 0) {
      const change = ((current.latency.p95 - previous.latency.p95) / previous.latency.p95) * 100;
      if (Math.abs(change) > threshold * 100) {
        current.regressions.push({
          metric: 'Latency P95',
          previous: previous.latency.p95,
          current: current.latency.p95,
          changePercent: change,
        });
      }
    }

    // Check build time
    if (previous.buildTime.total > 0) {
      const change =
        ((current.buildTime.total - previous.buildTime.total) /
          previous.buildTime.total) *
        100;
      if (Math.abs(change) > threshold * 100) {
        current.regressions.push({
          metric: 'Build Time',
          previous: previous.buildTime.total,
          current: current.buildTime.total,
          changePercent: change,
        });
      }
    }

    // Check error rate
    if (previous.errorRate > 0) {
      const change =
        ((current.errorRate - previous.errorRate) / previous.errorRate) * 100;
      if (change > threshold * 100) {
        current.regressions.push({
          metric: 'Error Rate',
          previous: previous.errorRate,
          current: current.errorRate,
          changePercent: change,
        });
      }
    }
  }

  private estimateFrontendSize(): number {
    // Estimate based on Next.js build output if available
    const buildPath = join(this.workspacePath, 'frontend', '.next');
    if (existsSync(buildPath)) {
      // Would calculate actual size
      return 500 * 1024; // 500 KB estimate
    }
    return 500 * 1024;
  }

  private estimateAPISize(): number {
    // Estimate API response size
    return 50 * 1024; // 50 KB estimate
  }
}
